; contract: https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/deposit_contract/contracts/validator_registration.v.py

[root]
k: #execute
; default
pc: 0 => _
word_stack: .WordStack => _
local_mem: .Map => _
gas: #symGas(0) => _
memory_used: #symMem(0) => _
; no changes
call_data: _
log: _
refund: _
storage: _
orig_storage: _
balance: INIT_BALANCE
nonce: INIT_NONCE
; ignore (potential) changes
output: _ => _
status_code: _ => _
; variables
comment:
schedule:       PETERSBURG
call_stack:     CALL_STACK
this:           THIS
msg_sender:     MSG_SENDER
call_value:     CALL_VALUE
call_depth:     CALL_DEPTH
coinbase:       COIN_BASE
active_accounts:
accounts:
requires:
    // conditions
    andBool #range(0 <= CALL_DEPTH < 1024)
    andBool #regularAddress({SCHEDULE}, THIS)
    // types
    andBool #rangeAddress(THIS)
    andBool #rangeAddress(MSG_SENDER)
    andBool #rangeUInt(256, CALL_VALUE)
;   andBool #rangeUInt(256, INIT_GAS)
    andBool #rangeUInt(256, INIT_BALANCE)
    andBool #rangeUInt(256, INIT_NONCE)
    andBool #rangeUInt(256, EXTRA_CALL_DATA_SIZE)
ensures:
attribute:
VYPER_GENERATED_BOUNDS:
    ; bounds - vyper generated
    [  32 := #buf(32, 1461501637330902918203684832716283019655932542976) ]
    [  64 := #buf(32, 170141183460469231731687303715884105727) ]
    [  96 := #buf(32, 115792089237316195423570985008687907853099843482180094807725896704197245534208) ]
    [ 128 := #buf(32, 1701411834604692317316873037158841057270000000000) ]
    [ 160 := #buf(32, 115792089237316195423570985006986496018665292348323691002298742950633129639936) ]
LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT:
    [ 352 := #buf(32, {RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64}) ]  /* return address */
    [ 320 := #buf(32, DEPOSIT_COUNT) ]  /* argument */
    [ 384 := #buf(32, Y8) ]             /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, X8) ]             /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, 8) ]              /* for-loop index */
    [ 480 := #buf(32, X7 &Int 255) ]    /* bitwise_and(x, 255) */
    [ 544 := #buf(32, Y8) ]             /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, 8) ]              /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]  /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT:
    [ 352 := #buf(32, {RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}) ]  /* return address */
    [ 320 := #buf(32, {DEPOSIT_AMOUNT}) ]   /* argument */
    [ 384 := #buf(32, YY8) ]                /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, XX8) ]                /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, 8) ]                  /* for-loop index */
    [ 480 := #buf(32, XX7 &Int 255) ]       /* bitwise_and(x, 255) */
    [ 544 := #buf(32, YY8) ]                /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, 8) ]                  /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]  /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
TO_LITTLE_ENDIAN_64_ZERO_PADDING:
    [ 800 := #buf(32, 16) ]             /* padding loop index */
    [ 744 <- 0 ]                        /* padding */
    [ 745 <- 0 ]
    [ 746 <- 0 ]
    [ 747 <- 0 ]
    [ 748 <- 0 ]
    [ 749 <- 0 ]
    [ 750 <- 0 ]
    [ 751 <- 0 ]
    [ 672 := #buf(32, 32) ]             /* ??? */
    [ 640 := #buf(32, 0) ]              /* ??? */
LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT:
    // let-bindings
    andBool X1 ==Int DEPOSIT_COUNT /Int 256
    andBool X2 ==Int X1            /Int 256
    andBool X3 ==Int X2            /Int 256
    andBool X4 ==Int X3            /Int 256
    andBool X5 ==Int X4            /Int 256
    andBool X6 ==Int X5            /Int 256
    andBool X7 ==Int X6            /Int 256
    andBool X8 ==Int X7            /Int 256
    //
    andBool Y1 ==Int          DEPOSIT_COUNT &Int 255
    andBool Y2 ==Int (Y1 *Int 256) +Int (X1 &Int 255)
    andBool Y3 ==Int (Y2 *Int 256) +Int (X2 &Int 255)
    andBool Y4 ==Int (Y3 *Int 256) +Int (X3 &Int 255)
    andBool Y5 ==Int (Y4 *Int 256) +Int (X4 &Int 255)
    andBool Y6 ==Int (Y5 *Int 256) +Int (X5 &Int 255)
    andBool Y7 ==Int (Y6 *Int 256) +Int (X6 &Int 255)
    andBool Y8 ==Int (Y7 *Int 256) +Int (X7 &Int 255)
LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT:
    // let-bindings
    andBool XX1 ==Int {DEPOSIT_AMOUNT} /Int 256
    andBool XX2 ==Int XX1              /Int 256
    andBool XX3 ==Int XX2              /Int 256
    andBool XX4 ==Int XX3              /Int 256
    andBool XX5 ==Int XX4              /Int 256
    andBool XX6 ==Int XX5              /Int 256
    andBool XX7 ==Int XX6              /Int 256
    andBool XX8 ==Int XX7              /Int 256
    //
    andBool YY1 ==Int         {DEPOSIT_AMOUNT} &Int 255
    andBool YY2 ==Int (YY1 *Int 256) +Int (XX1 &Int 255)
    andBool YY3 ==Int (YY2 *Int 256) +Int (XX2 &Int 255)
    andBool YY4 ==Int (YY3 *Int 256) +Int (XX3 &Int 255)
    andBool YY5 ==Int (YY4 *Int 256) +Int (XX4 &Int 255)
    andBool YY6 ==Int (YY5 *Int 256) +Int (XX5 &Int 255)
    andBool YY7 ==Int (YY6 *Int 256) +Int (XX6 &Int 255)
    andBool YY8 ==Int (YY7 *Int 256) +Int (XX7 &Int 255)

[revert]
k: #execute => #halt
status_code: _ => EVMC_REVERT

; Revert if the first four bytes are invalid (or not fully provided).
[revert-invalid_function_identifier]
call_data: #buf(CALL_DATA_SIZE, CALL_DATA)
pc: 0 => 4473
gas:         #symGas(0 => 51)
memory_used: #symMem(0 => 51)

[revert-invalid_function_identifier-lt_4]
+requires:
    // conditions
    andBool #range(0 <= CALL_DATA_SIZE < 4)
    andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 2251960603 /* 0x863a311b get_hash_tree_root */
    andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 1646252336 /* 0x621fd130 get_deposit_count  */
    andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 3296604173 /* 0xc47e300d deposit            */

[revert-invalid_function_identifier-ge_4]
+requires:
    // conditions
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 2251960603 /* 0x863a311b get_hash_tree_root */
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 1646252336 /* 0x621fd130 get_deposit_count  */
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 3296604173 /* 0xc47e300d deposit            */

[revert-invalid_function_identifier-ge_4-lt_32]
+requires:
    // conditions
    andBool #range(4 <= CALL_DATA_SIZE < 32)

[revert-invalid_function_identifier-ge_4-ge_32]
+requires:
    // conditions
    andBool CALL_DATA_SIZE >=Int 32

;
; to_little_endian_64
;

[to_little_endian_64-trusted]
gas:         #symGas(N => N +Int {NUM_OPS_TO_LITTLE_ENDIAN_64})
memory_used: #symMem(N => N +Int {NUM_OPS_TO_LITTLE_ENDIAN_64})
attribute: [trusted, matching(#symGas,#symMem)]

[to_little_endian_64]
k: #execute
pc: {PC_BEGIN} => {PC_END}
word_stack: {WORD_STACK_BEGIN} => {WORD_STACK_END}
local_mem: {LOCAL_MEM_BEGIN} => {LOCAL_MEM_END}
LOOP_BOUND: 8
SLICE_LENGTH: 8
PC_BEGIN:  155
PC_MIDDLE: 373
PC_END:    628
WORD_STACK_BEGIN:  RETURN_ADDR : VALUE                 : WS /* WS saves caller's local vars */
WORD_STACK_MIDDLE: {LOOP_BOUND} : 448                  : WS
WORD_STACK_END:    RETURN_ADDR : 32 : 8 : {RETURN_VAL} : WS
; RETURN_VAL: selectRange({LOCAL_MEM_END}, 736, 32)
RETURN_VAL: #asWord(#bufSeg(#buf(32, Y8), 24, 8) ++ #buf(8, 0) ++ selectRange({LOCAL_MEM_BEGIN}, 752, 16))
LOCAL_MEM_BEGIN:  MEM
LOCAL_MEM_MIDDLE: {LOCAL_MEM_BEGIN}  {LOCAL_MEM_UPDATE_FROM_BEGIN_TO_MIDDLE}
LOCAL_MEM_END:    {LOCAL_MEM_MIDDLE} {LOCAL_MEM_UPDATE_FROM_MIDDLE_TO_END}
LOCAL_MEM_UPDATE_FROM_BEGIN_TO_MIDDLE:
    [ 352 := #buf(32, RETURN_ADDR) ]
    [ 320 := #buf(32, VALUE) ]
    [ 384 := #buf(32, Y8) ]             /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, X8) ]             /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, {LOOP_BOUND}) ]   /* for-loop index */
    [ 480 := #buf(32, X7 &Int 255) ]    /* bitwise_and(x, 255) */
LOCAL_MEM_UPDATE_FROM_MIDDLE_TO_END:
    [ 544 := #buf(32, Y8) ]             /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, {SLICE_LENGTH}) ] /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, {SLICE_LENGTH}) ++ #bufSeg(#buf(32, Y8), 24, {SLICE_LENGTH}) ]    /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    [ 800 := #buf(32, 16) ]             /* padding loop index */
    [ 744 <- 0 ]                        /* padding */
    [ 745 <- 0 ]
    [ 746 <- 0 ]
    [ 747 <- 0 ]
    [ 748 <- 0 ]
    [ 749 <- 0 ]
    [ 750 <- 0 ]
    [ 751 <- 0 ]
    [ 672 := #buf(32, 32) ]             /* ??? */
    [ 640 := #buf(32, 0) ]              /* ??? */
+requires:
    // conditions
    andBool #range(0 <= #sizeWordStack(WS) <= 1000) // NOTE: rough bound
    andBool #rangeUInt(256, RETURN_ADDR)
    andBool #rangeUInt(256, VALUE)
    // let-bindings
    andBool X1 ==Int VALUE /Int 256
    andBool X2 ==Int X1    /Int 256
    andBool X3 ==Int X2    /Int 256
    andBool X4 ==Int X3    /Int 256
    andBool X5 ==Int X4    /Int 256
    andBool X6 ==Int X5    /Int 256
    andBool X7 ==Int X6    /Int 256
    andBool X8 ==Int X7    /Int 256
    //
    andBool Y1 ==Int                  VALUE &Int 255
    andBool Y2 ==Int (Y1 *Int 256) +Int (X1 &Int 255)
    andBool Y3 ==Int (Y2 *Int 256) +Int (X2 &Int 255)
    andBool Y4 ==Int (Y3 *Int 256) +Int (X3 &Int 255)
    andBool Y5 ==Int (Y4 *Int 256) +Int (X4 &Int 255)
    andBool Y6 ==Int (Y5 *Int 256) +Int (X5 &Int 255)
    andBool Y7 ==Int (Y6 *Int 256) +Int (X6 &Int 255)
    andBool Y8 ==Int (Y7 *Int 256) +Int (X7 &Int 255)
gas:         #symGas(0 => {NUM_OPS_TO_LITTLE_ENDIAN_64})
memory_used: #symMem(0 => {NUM_OPS_TO_LITTLE_ENDIAN_64})
NUM_OPS_TO_LITTLE_ENDIAN_64: 1126

[to_little_endian_64-forloop]
pc: {PC_BEGIN} => {PC_MIDDLE}
word_stack: {WORD_STACK_BEGIN} => {WORD_STACK_MIDDLE}
local_mem: {LOCAL_MEM_BEGIN} => {LOCAL_MEM_MIDDLE}
;   ; save call stack args
;   [ 352 := #buf(32, RETURN_ADDR) ]
;   [ 320 := #buf(32, VALUE) ]
;   ; init locals
;   [ 384 := #buf(32, 0) ]                  /* y: uint256 = 0 */
;   [ 416 := #buf(32, VALUE) ]              /* x: uint256 = value */
;   [ 448 := #buf(32, 0) ]                  /* init for-loop index */
;   ; loop body (pc: 189 <-> 372)
;   [ 384 := #buf(32, 0) ]                  /* y = shift(y, 8) */ /* y << 8 */
;   [ 480 := #buf(32, VALUE &Int 255) ]     /* bitwise_and(x, 255) */
;   [ 384 := #buf(32, VALUE &Int 255) ]     /* y = y + bitwise_and(x, 255) */
;   [ 416 := #buf(32, VALUE /Int 256) ]     /* x = shift(x, -8) */ /* x >> 8 */
;   [ 448 := #buf(32, 1) ]                  /* increase for-loop index */
;   ; ... repeat loop body ...

[to_little_endian_64-return]
pc: {PC_MIDDLE} => {PC_END}
word_stack: {WORD_STACK_MIDDLE} => {WORD_STACK_END}
local_mem: {LOCAL_MEM_MIDDLE} => {LOCAL_MEM_END}
;   [ 544 := #buf(32, Y8) ]                 /* memcpy 544 <- 384 */
;   [ 536 := #buf(32, 8) ]                  /* slice by overwrite */
;   [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8)) ]         /* prepareing for return value*/
;
;   [ 800 := #buf(32, 8) ]
;   [ 744 <- 0 ]
;   [ 800 := #buf(32, 9) ]
;   [ 745 <- 0 ]
;   ...
;   [ 751 <- 0 ]                            /* padding */
;   [ 800 := #buf(32, 16) ]                 /* padding loop index */
;
;   [ 672 := #buf(32, 32) ]
;   [ 640 := #buf(32, 96) ]
;   [ 640 := #buf(32, 64) ]
;   [ 640 := #buf(32, 32) ]
;   [ 640 := #buf(32, 0) ]

;
; get_hash_tree_root
;

[get_hash_tree_root]
call_data: #abiCallData("get_hash_tree_root", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
storage: M
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
WORD_STACK_INIT: 32 : 416 : .WordStack
LOCAL_MEM_BEGIN: .Map
    ; function hash
    [  28 := 134 : 58 : 49 : 27 : #take(28, #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)) ]
;   [  28 <- 134 ]
;   [  29 <-  58 ]
;   [  30 <-  49 ]
;   [  31 <-  27 ]
    {VYPER_GENERATED_BOUNDS}
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; locals
    [ 320 := #buf(32, 0) ]              /* zero_bytes32: bytes32 = 0x0 */
    [ 352 := #buf(32, 0) ]              /* node: bytes32 = zero_bytes32 */
    [ 384 := #buf(32, DEPOSIT_COUNT) ]  /* size: uint256 = self.deposit_count */
    [ 416 := #buf(32, 0) ]              /* height = 0 */

[get_hash_tree_root-init]
pc: 0 => 689
word_stack: .WordStack => {WORD_STACK_INIT}
local_mem: .Map => {LOCAL_MEM_INIT}
gas:         #symGas(0 => 54)
memory_used: #symMem(0 => 54)
; gas: #gas(INIT_GAS, 0, 0) => _ /* #gas(INIT_GAS, 375, 42) */
; memory_used: 0 => _ /* 14 */

[get_hash_tree_root-loop0]
pc: 689 => 960
word_stack: {WORD_STACK_INIT} => 1 : {WORD_STACK_INIT}

[get_hash_tree_root-loop0-then]
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 0) ]                              /* branch storage index = 0 */
    [ 608 := #buf(32, {BRANCH_0}) ]                     /* branch[0] */
    [ 640 := #buf(32, 0) ]                              /* node */
    [ 576 := #buf(32, 64) ]                             /* size of sha256 input */
    [ 192 := #buf(32, {NODE_1}) ]                       /* sha256 return value via sha256(608, 64) */
    [ 352 := #buf(32, {NODE_1}) ]                       /* update node = sha256(branch[0], node) */
    [ 384 := #buf(32, DEPOSIT_COUNT /Int 2) ]           /* update size */
    [ 416 := #buf(32, 1) ]                              /* update height */
BRANCH_0: select(M, #hashedLocation({COMPILER}, {BRANCH}, 0))
NODE_1: #sha256(#buf(32, {BRANCH_0}) ++ #buf(32, 0))
+requires:
    // conditions
    andBool DEPOSIT_COUNT &Int 1 ==Int 1
gas:         #symGas(N => N +Int 100)
memory_used: #symMem(N => N +Int 100)
; gas: #gas(INIT_GAS, 375, 42) => _ /* #gas(INIT_GAS, Cgascap(PETERSBURG, #gas(INIT_GAS, 812, 63), #gas(INIT_GAS, 812, 63), 700) +Int 1512 -Int INIT_GAS +Int 1003, 126) */
; memory_used: 14 => _ /* 21 */

[get_hash_tree_root-loop0-else]
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 480 := #buf(32, 0) ]                              /* node */
    [ 192 := #buf(32, 2) ]                              /* zero_hashes storage index = 2 */
    [ 512 := #buf(32, {ZERO_HASHES_0}) ]                /* zero_hashes[0] */
    [ 448 := #buf(32, 64) ]                             /* size of sha256 input */
    [ 192 := #buf(32, {NODE_1}) ]                       /* sha256 return value via sha256(480, 64) */
    [ 352 := #buf(32, {NODE_1}) ]                       /* update node = sha256(node, zero_hashes[0]) */
    [ 384 := #buf(32, DEPOSIT_COUNT /Int 2) ]           /* update size */
    [ 416 := #buf(32, 1) ]                              /* update height */
ZERO_HASHES_0: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))
NODE_1: #sha256(#buf(32, 0) ++ #buf(32, {ZERO_HASHES_0}))
+requires:
    // conditions
    andBool DEPOSIT_COUNT &Int 1 =/=Int 1
gas:         #symGas(N => N +Int 99)
memory_used: #symMem(N => N +Int 99)
; gas: #gas(INIT_GAS, 375, 42) => _ /* #gas(INIT_GAS, Cgascap(PETERSBURG, #gas(INIT_GAS, 813, 51), #gas(INIT_GAS, 813, 51), 700) +Int 1513 -Int INIT_GAS +Int 993, 102) */
; memory_used: 14 => _ /* 17 */

[get_hash_tree_root-loop]
PC_LOOPHEAD: 960
; MEMORY_USED_LOOPHEAD: 17 or 21
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_BEGIN}
    ; locals
    [ 320 := #buf(32, 0) ]          /* zero_bytes32: bytes32 = 0x0 */
    [ 352 := #buf(32, NODE) ]       /* node: bytes32 */
    [ 384 := #buf(32, SIZE) ]       /* size: uint256 */
    [ 416 := #buf(32, HEIGHT) ]     /* height */
    ; garbages
    [ 192 := #buf(32, ANON_1) ]     /* sha256 return value */
    // for if-then branch
    [ 576 := #buf(32, ANON_2) ]     /* size of sha256 input */
    [ 608 := #buf(32, ANON_3) ]     /* branch[height] */
    [ 640 := #buf(32, ANON_4) ]     /* node */
    // for if-else branch
    [ 448 := #buf(32, ANON_5) ]     /* size of sha256 input */
    [ 480 := #buf(32, ANON_6) ]     /* node */
    [ 512 := #buf(32, ANON_7) ]     /* zero_hashes[height] */
+requires:
    // conditions
    andBool #range(0 <= HEIGHT <= 32)
    // types
    andBool #rangeUInt(256, NODE)
    andBool #rangeUInt(256, SIZE)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)
    andBool #rangeUInt(256, ANON_3)
    andBool #rangeUInt(256, ANON_4)
    andBool #rangeUInt(256, ANON_5)
    andBool #rangeUInt(256, ANON_6)
    andBool #rangeUInt(256, ANON_7)

[get_hash_tree_root-loop-body]
pc: {PC_LOOPHEAD}
word_stack: (HEIGHT => HEIGHT +Int 1) : {WORD_STACK_INIT}
+requires:
    // conditions
    andBool HEIGHT <Int 32

[get_hash_tree_root-loop-body-then]
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 192 := #buf(32, 0) ]                      /* branch storage index = 0 */
    [ 608 := #buf(32, {BRANCH_HEIGHT}) ]        /* branch[height] */
    [ 640 := #buf(32, NODE) ]                   /* node */
    [ 576 := #buf(32, 64) ]                     /* size of sha256 input */
    [ 192 := #buf(32, {NODE_NEW}) ]             /* sha256 return value */
    [ 352 := #buf(32, {NODE_NEW}) ]             /* update node */
    [ 384 := #buf(32, SIZE /Int 2) ]            /* update size */
    [ 416 := #buf(32, HEIGHT +Int 1) ]          /* update height */
BRANCH_HEIGHT: select(M, #hashedLocation({COMPILER}, {BRANCH}, HEIGHT))
NODE_NEW: #sha256(#buf(32, {BRANCH_HEIGHT}) ++ #buf(32, NODE))
+requires:
    // conditions
    andBool SIZE &Int 1 ==Int 1
gas:         #symGas(N => N +Int 105)
memory_used: #symMem(N => N +Int 105)
; gas: #gas(INIT_GAS, 0, 0) => _ /* #gas(INIT_GAS, Cgascap(PETERSBURG, #gas(INIT_GAS, 459, 0), #gas(INIT_GAS, 459, 0), 700) +Int 1159 -Int INIT_GAS +Int 650, 0) */
; memory_used: {MEMORY_USED_LOOPHEAD}

[get_hash_tree_root-loop-body-else]
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 480 := #buf(32, NODE) ]                   /* node */
    [ 192 := #buf(32, 2) ]                      /* zero_hashes storage index = 2 */
    [ 512 := #buf(32, {ZERO_HASHES_HEIGHT}) ]   /* zero_hashes[height] */
    [ 448 := #buf(32, 64) ]                     /* size of sha256 input */
    [ 192 := #buf(32, {NODE_NEW}) ]             /* sha256 return value via sha256(480, 64) */
    [ 352 := #buf(32, {NODE_NEW}) ]             /* update node = sha256(node, zero_hashes[height]) */
    [ 384 := #buf(32, SIZE /Int 2) ]            /* update size = size / 2 */
    [ 416 := #buf(32, HEIGHT +Int 1) ]          /* update height = height + 1 */
ZERO_HASHES_HEIGHT: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, HEIGHT))
NODE_NEW: #sha256(#buf(32, NODE) ++ #buf(32, {ZERO_HASHES_HEIGHT}))
+requires:
    // conditions
    andBool SIZE &Int 1 =/=Int 1
gas:         #symGas(N => N +Int 104)
memory_used: #symMem(N => N +Int 104)
; gas: #gas(INIT_GAS, 0, 0) => _ /* #gas(INIT_GAS, Cgascap(PETERSBURG, #gas(INIT_GAS, 460, 0), #gas(INIT_GAS, 460, 0), 700) +Int 1160 -Int INIT_GAS +Int 640, 0) */
; memory_used: {MEMORY_USED_LOOPHEAD}

[get_hash_tree_root-loop-exit]
k: #execute => #halt
pc: {PC_LOOPHEAD} => 1286
RETURN_VAL: #sha256(#buf(32, NODE) ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0))
output: _ => #buf(32, {RETURN_VAL})
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    ; preparing for calling to_little_endian_64
    [ 1120 := #buf(32, NODE) ]
    [  704 := #buf(32, 2154246793) ]            /* 0x80673289 */ /* ??? */
    [  736 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64 (pc: 1030 -> [155 -> ... -> 628] -> 1031)
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; finish
    [  832 := #buf(32, 8) ]
    [  928 := #buf(32, 0) ]
    [  864 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(8, 0) ++ #bufSeg(#buf(32, DEPOSIT_COUNT), 16, 16) ]    /* the last bufSeg term came from the previous entry [ 736 := #buf(32, DEPOSIT_COUNT) ] before to_little_endian_64 call */
    [  928 := #buf(32, 32) ]
    [  384 := #buf(32, SIZE) ]                  /* restore size: uint256 */
    [  352 := #buf(32, NODE) ]                  /* restore node: bytes32 */
    [  320 := #buf(32, 0) ]                     /* restore zero_bytes32: bytes32 */
    [ 1152 := #bufSeg(#buf(32, Y8), 24, 8) ]    /* self.to_little_endian_64(self.deposit_count) */  /* via memcpy(1152 <- 864,  8) */
    [  992 := #buf(32, 0) ]                     /* zero_bytes32 */                                  /* via memcpy( 992 <- 320, 32) */
    [  960 := #buf(32, 24) ]                    /* slice len */
    [ 1160 := #buf(24, 0) ]                     /* slice(zero_bytes32, start=0, len=24) */          /* via memcpy(1160 <- 992, 24) */
    [ 1088 := #buf(32, 64) ]
    [  192 := #buf(32, {RETURN_VAL}) ]          /* via sha256(1120, 64) */
    [    0 := #buf(32, {RETURN_VAL}) ]          /* return sha256(concat(node, self.to_little_endian_64(self.deposit_count), slice(zero_bytes32, start=0, len=24))) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64: 1031
+requires:
    // conditions
    andBool HEIGHT ==Int 32
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
gas:         #symGas(N => N +Int 1356)
memory_used: #symMem(N => N +Int 1356)

;
; get_deposit_count
;

[get_deposit_count]
; The term `#buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)` models certain extra call-data added accidently or intentionally.
; This ensures that the function works correctly even in such a case.
call_data: #abiCallData("get_deposit_count", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
storage: M
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
LOCAL_MEM_BEGIN: .Map
    ; function hash
    [  28 := 98 : 31 : 209 : 48 : #take(28, #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)) ]
;   [  28 <-  98 ]
;   [  29 <-  31 ]
;   [  30 <- 209 ]
;   [  31 <-  48 ]
    {VYPER_GENERATED_BOUNDS}
k: #execute => #halt
pc: 0 => 1560
output: _ => #buf(32, 32) ++ #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(8, 0) ++ #buf(16, 32)
           ; 608             640            672                             680           688          704
           ; NOTE: the last term #buf(16, 32) came from the garbage of to_little_endian_64 call: [ 672 := #buf(32, 32) ]
word_stack: .WordStack
local_mem: .Map => {LOCAL_MEM_BEGIN}
    ; before call
    [ 320 := #buf(32, 2154246793) ]     /* 0x80673289 */ /* ??? */
    [ 352 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; after call
    [ 448 := #buf(32, 8) ]
    [ 544 := #buf(32, 0) ]
    [ 480 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]  /* return value from to_little_endian_64 */
    [ 544 := #buf(32, 32) ]
    [ 640 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]  /* memcpy(640 <- 448, 40) */
    [ 736 := #buf(32, 8) ]                                  /* zero padding loop index */
    [ 680 <- 0 ]                                            /* zero padding */
    [ 736 := #buf(32, 9) ]
    [ 681 <- 0 ]
    [ 736 := #buf(32, 10) ]
    [ 682 <- 0 ]
    [ 736 := #buf(32, 11) ]
    [ 683 <- 0 ]
    [ 736 := #buf(32, 12) ]
    [ 684 <- 0 ]
    [ 736 := #buf(32, 13) ]
    [ 685 <- 0 ]
    [ 736 := #buf(32, 14) ]
    [ 686 <- 0 ]
    [ 736 := #buf(32, 15) ]
    [ 687 <- 0 ]
    [ 736 := #buf(32, 16) ]
    [ 608 := #buf(32, 32) ]                                 /* return(608, 96) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64: 1342
gas:         #symGas(0 => 1542)
memory_used: #symMem(0 => 1542)

;
; deposit
;

; TODO: explore when call_data is not well-formed, e.g., some arguments are not provided

[deposit]
; #buf(32, 96) ++ #buf(32, 192) ++ #buf(32, 256)        // header
; ++ #buf(32, 48) ++ #buf(48, PUBKEY) ++ #buf(16, 0)    // pubkey + zero-padding
; ++ #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS)   // withdrawal_credentials
; ++ #buf(32, 96) ++ #buf(96, SIGNATURE)                // signature
call_data: #abiCallData("deposit", (
            #bytes(#buf({PUBKEY_LENGTH},                 PUBKEY)),
            #bytes(#buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)),
            #bytes(#buf({SIGNATURE_LENGTH},              SIGNATURE)) ))
storage: M
+requires:
    // ranges
    andBool #range(0 <= PUBKEY                 < 2 ^Int ({PUBKEY_LENGTH}                 *Int 8))
    andBool #range(0 <= WITHDRAWAL_CREDENTIALS < 2 ^Int ({WITHDRAWAL_CREDENTIALS_LENGTH} *Int 8))
    andBool #range(0 <= SIGNATURE              < 2 ^Int ({SIGNATURE_LENGTH}              *Int 8))
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}
    // conditions
    andBool DEPOSIT_COUNT <Int {MAX_DEPOSIT_COUNT}
    andBool CALL_VALUE /Int {GWEI_IN_WEI} >=Int {MIN_DEPOSIT_AMOUNT}
PUBKEY_LENGTH:                 48
WITHDRAWAL_CREDENTIALS_LENGTH: 32
SIGNATURE_LENGTH:              96
MAX_DEPOSIT_COUNT:  4294967295
GWEI_IN_WEI:        1000000000
MIN_DEPOSIT_AMOUNT: 1000000000
DEPOSIT_AMOUNT: (CALL_VALUE /Int {GWEI_IN_WEI})
LOCAL_MEM_BEGIN: .Map
    {LOCAL_MEM_DEPOSIT_FUNCTION_HASH}
    {VYPER_GENERATED_BOUNDS}
LOCAL_MEM_DEPOSIT_FUNCTION_HASH:
    ; function hash
    [  28 <- 196 ]
    [  29 <- 126 ]
    [  30 <-  48 ]
    [  31 <-  13 ]
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; load calldata
    [  320 := #buf(32, 96) ++ #buf(32, 192) ++ #buf(32, 256) ]      /* calldatacopy(320,   4,  96) */
    [  416 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* calldatacopy(416, 100,  80) */
    [  544 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /* calldatacopy(544, 196,  64) */
    [  640 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /* calldatacopy(640, 260, 128) */
    [  832 := #buf(32, {GWEI_IN_WEI}) ]                             /* 1 gwei = 10^9 wei */
    [  800 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /* deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei") */
LOCAL_MEM_SUBCALL_1: {LOCAL_MEM_INIT}
    ; before call
    [  960 := #buf(32, 2154246793) ]                                /* ??? */
    [  992 := #buf(32, {DEPOSIT_AMOUNT}) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}
    ; after call
    [ 1088 := #buf(32, 8) ]
    [ 1184 := #buf(32, 0) ]
    [ 1120 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(8, 0) ++ #bufSeg(#buf(96, SIGNATURE), 80, 16) ]
    [ 1184 := #buf(32, 32) ]
    ; restore stack
    [  928 := #buf(32, 0) ]
    [  896 := #buf(32, 0) ]
    [  864 := #buf(32, 0) ]
    [  832 := #buf(32, {GWEI_IN_WEI}) ]
    [  800 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  768 := #buf(32, 0) ]
    [  736 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]
    [  704 := #bufSeg(#buf(96, SIGNATURE), 32, 32) ]
    [  672 := #bufSeg(#buf(96, SIGNATURE),  0, 32) ]
    [  640 := #buf(32, 96) ]
    [  608 := #buf(32, 0) ]
    [  576 := #buf(32, WITHDRAWAL_CREDENTIALS) ]
    [  544 := #buf(32, 32) ]
    [  512 := #buf(32, 0) ]
    [  480 := #bufSeg(#buf(48, PUBKEY), 32, 16) ++ #buf(16, 0) ]
    [  448 := #bufSeg(#buf(48, PUBKEY),  0, 32) ]
    [  416 := #buf(32, 48) ]
    [  864 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]    /* memcpy(864 <- 1088, 40) */ /* amount: bytes[8] = self.to_little_endian_64(deposit_amount) */
LOCAL_MEM_SUBCALL_2: {LOCAL_MEM_SUBCALL_1}
    ; before call
    [ 1216 := #buf(32, 2154246793) ]                                /* ??? */
    [ 1248 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; after call
    [ 1344 := #buf(32, 8) ]
    [ 1440 := #buf(32, 0) ]
    [ 1376 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(8, 0) ++ #bufSeg(#buf(96, SIGNATURE), 80, 16) ]
    [ 1440 := #buf(32, 32) ]
    ; restore stack
    [ 1184 := #buf(32, 32) ]
    [ 1152 := #buf(32, 0) ]
    [ 1120 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(8, 0) ++ #bufSeg(#buf(96, SIGNATURE), 80, 16) ]
    [ 1088 := #buf(32, 8) ]
    [ 1056 := #buf(32, 0) ]
    [ 1024 := #buf(32, 0) ]
    [  992 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  960 := #buf(32, 2154246793) ]
    [  928 := #buf(32, 0) ]
    [  896 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [  864 := #buf(32, 8) ]
    [  832 := #buf(32, {GWEI_IN_WEI}) ]
    [  800 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  768 := #buf(32, 0) ]
    [  736 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]
    [  704 := #bufSeg(#buf(96, SIGNATURE), 32, 32) ]
    [  672 := #bufSeg(#buf(96, SIGNATURE),  0, 32) ]
    [  640 := #buf(32, 96) ]
    [  608 := #buf(32, 0) ]
    [  576 := #buf(32, WITHDRAWAL_CREDENTIALS) ]
    [  544 := #buf(32, 32) ]
    [  512 := #buf(32, 0) ]
    [  480 := #bufSeg(#buf(48, PUBKEY), 32, 16) ++ #buf(16, 0) ]
    [  448 := #bufSeg(#buf(48, PUBKEY),  0, 32) ]
    [  416 := #buf(32, 48) ]
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT: 1896
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64:                2201
LOCAL_MEM_LOG: {LOCAL_MEM_SUBCALL_2}
    [ 1472 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ] /* memcpy(1472 <- 1344, 40) */
    [ 1600 := #buf(32, 160) ]
    [ 1664 := #buf(32, 160) ]
    [ 1824 := #buf(32, 48) ++ #buf(48, PUBKEY) ] /* memcpy(1824 <- 416, 80) */
    [ 1568 := #buf(32, 64) ]    /* padding index */
    [ 1904 <- 0 ]
    [ 1905 <- 0 ]
    [ 1906 <- 0 ]
    [ 1907 <- 0 ]
    [ 1908 <- 0 ]
    [ 1909 <- 0 ]
    [ 1910 <- 0 ]
    [ 1911 <- 0 ]
    [ 1912 <- 0 ]
    [ 1913 <- 0 ]
    [ 1914 <- 0 ]
    [ 1915 <- 0 ]
    [ 1916 <- 0 ]
    [ 1917 <- 0 ]
    [ 1918 <- 0 ]
    [ 1919 <- 0 ]
    [ 1600 := #buf(32, 256) ]
    [ 1696 := #buf(32, 256) ]
    [ 1920 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ] /* memcpy(1920 <- 544, 64) */
    [ 1568 := #buf(32, 32) ]    /* padding index */
    [ 1600 := #buf(32, 320) ]
    [ 1728 := #buf(32, 320) ]
    [ 1984 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ] /* memcpy(1984 <- 864, 40) */
    [ 1568 := #buf(32, 32) ]    /* padding index */
    [ 2024 <- 0 ]
    [ 2025 <- 0 ]
    [ 2026 <- 0 ]
    [ 2027 <- 0 ]
    [ 2028 <- 0 ]
    [ 2029 <- 0 ]
    [ 2030 <- 0 ]
    [ 2031 <- 0 ]
    [ 2032 <- 0 ]
    [ 2033 <- 0 ]
    [ 2034 <- 0 ]
    [ 2035 <- 0 ]
    [ 2036 <- 0 ]
    [ 2037 <- 0 ]
    [ 2038 <- 0 ]
    [ 2039 <- 0 ]
    [ 2040 <- 0 ]
    [ 2041 <- 0 ]
    [ 2042 <- 0 ]
    [ 2043 <- 0 ]
    [ 2044 <- 0 ]
    [ 2045 <- 0 ]
    [ 2046 <- 0 ]
    [ 2047 <- 0 ]
    [ 1600 := #buf(32, 384) ]
    [ 1760 := #buf(32, 384) ]
    [ 2048 := #buf(32, 96) ++ #buf(96, SIGNATURE) ] /* memcpy(2048 <- 640, 128) */
    [ 1568 := #buf(32, 96) ]    /* padding index */
    [ 1600 := #buf(32, 512) ]
    [ 1792 := #buf(32, 512) ]
    [ 2176 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ] /* memcpy(2176 <- 1472, 40) */
    [ 1568 := #buf(32, 32) ]    /* padding index */
    [ 2216 <- 0 ]
    [ 2217 <- 0 ]
    [ 2218 <- 0 ]
    [ 2219 <- 0 ]
    [ 2220 <- 0 ]
    [ 2221 <- 0 ]
    [ 2222 <- 0 ]
    [ 2223 <- 0 ]
    [ 2224 <- 0 ]
    [ 2225 <- 0 ]
    [ 2226 <- 0 ]
    [ 2227 <- 0 ]
    [ 2228 <- 0 ]
    [ 2229 <- 0 ]
    [ 2230 <- 0 ]
    [ 2231 <- 0 ]
    [ 2232 <- 0 ]
    [ 2233 <- 0 ]
    [ 2234 <- 0 ]
    [ 2235 <- 0 ]
    [ 2236 <- 0 ]
    [ 2237 <- 0 ]
    [ 2238 <- 0 ]
    [ 2239 <- 0 ]
    [ 1600 := #buf(32, 576) ]
LOCAL_MEM_LOG_ABSTRACT: MEM
    {LOCAL_MEM_DEPOSIT_FUNCTION_HASH}
    {VYPER_GENERATED_BOUNDS}
    ; function arguments and locals
    [  416 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* def deposit(pubkey: bytes[PUBKEY_LENGTH],                                    */
    [  496 := #buf(16, 0) ]
    [  512 := #buf(32, 0) ]
    [  544 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /*             withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],    */
    [  608 := #buf(32, 0) ]
    [  640 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /*             signature: bytes[SIGNATURE_LENGTH]):                             */
    [  768 := #buf(32, 0) ]
    [  800 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /*     deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei")            */
    [  832 := #buf(32, {GWEI_IN_WEI}) ]
    [  864 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]        /*     amount: bytes[8] = self.to_little_endian_64(deposit_amount)              */
    [  904 := #buf(24, 0) ]
LOCAL_MEM_DATA: {LOCAL_MEM_LOG}
    [ 1824 := #buf(32, 0) ]                             /* zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000 */
    [ 2048 := #buf(48, PUBKEY) ]                        /* memcpy(2048 <- 448, 48) */
    [ 1920 := #buf(32, 0) ]                             /* memcpy(1920 <- 1824, 32) */
    [ 1888 := #buf(32, 16) ]                            /* len=64 - PUBKEY_LENGTH */
    [ 2096 := #buf(16, 0) ]
    [ 2016 := #buf(32, 64) ]
    [  192 := #buf(32, {PUBKEY_ROOT}) ]                 /* sha256(2048, 64) */
    [ 1856 := #buf(32, {PUBKEY_ROOT}) ]                 /* pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH))) */
    [ 2208 := #buf(96, SIGNATURE) ]                     /* memcpy(2208 <- 672, 96) */
    [ 2176 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP1}) ]                        /* sha256(2208, 64) */
    [ 2720 := #buf(32, {TMP1}) ]                        /* sha256(slice(signature, start=0, len=64)), */
    [ 2400 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ++ #buf(32, 0) ++ #buf(32, {DEPOSIT_AMOUNT}) ]   /* memcpy(2400 <- 736, 96) */   /* TODO: ??? */
    [ 2368 := #buf(32, 32) ]                            /* len=SIGNATURE_LENGTH - 64 */
    [ 2592 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]    /* memcpy(2592 <- 2400, 32) */
    [ 2624 := #buf(32, 0) ]
    [ 2560 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP2}) ]                        /* sha256(2592, 64) */
    [ 2752 := #buf(32, {TMP2}) ]                        /* sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)), */
    [ 2688 := #buf(32, 64) ]
    [  192 := #buf(32, {SIGNATURE_ROOT}) ]              /* sha256(2720, 64) */
    [ 2144 := #buf(32, {SIGNATURE_ROOT}) ]              /* signature_root: bytes32 = sha256(concat(...)) */
    [ 2880 := #buf(32, {PUBKEY_ROOT}) ]
    [ 2912 := #buf(32, WITHDRAWAL_CREDENTIALS) ]        /* memcpy(2912 <- 576, 32) */
    [ 2848 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP3}) ]                        /* sha256(2880, 64) */
    [ 3264 := #buf(32, {TMP3}) ]                        /* sha256(concat(pubkey_root, withdrawal_credentials)), */
    [ 3136 := #bufSeg(#buf(32, YY8), 24, 8) ]           /* memcpy(3136 <- 896, 8) */
    [ 3008 := #buf(32, 0) ]                             /* memcpy(3008 <- 1824, 32) */
    [ 2976 := #buf(32, 24) ]                            /* len=32 - AMOUNT_LENGTH */
    [ 3144 := #buf(24, 0) ]                             /* memcpy(3144 <- 3008, 24) */
    [ 3168 := #buf(32, {SIGNATURE_ROOT}) ]
    [ 3104 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP4}) ]                        /* sha256(3136, 64) */
    [ 3296 := #buf(32, {TMP4}) ]                        /* sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)), */
    [ 3232 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE}) ]                        /* sha256(3264, 64) */
    [ 2816 := #buf(32, {NODE}) ]                        /* node: bytes32 = sha256(concat(...)) */
PUBKEY_ROOT: #sha256(#buf(48, PUBKEY) ++ #buf(16, 0))
TMP1: #sha256(#bufSeg(#buf(96, SIGNATURE), 0, 64))
TMP2: #sha256(#bufSeg(#buf(96, SIGNATURE), 64, 32) ++ #buf(32, 0))
SIGNATURE_ROOT: #sha256(#buf(32, {TMP1}) ++ #buf(32, {TMP2}))
TMP3: #sha256(#buf(32, {PUBKEY_ROOT}) ++ #buf(32, WITHDRAWAL_CREDENTIALS))
TMP4: #sha256(#bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ++ #buf(32, {SIGNATURE_ROOT}))
NODE: #sha256(#buf(32, {TMP3}) ++ #buf(32, {TMP4}))

; @payable
; @public
; def deposit(pubkey: bytes[PUBKEY_LENGTH],
;             withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],
;             signature: bytes[SIGNATURE_LENGTH]):
;
;     # Avoid overflowing the Merkle tree (and prevent edge case in computing `self.branch`)
;     assert self.deposit_count < MAX_DEPOSIT_COUNT
;
;     # Validate deposit data
;     deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei")
;     assert deposit_amount >= MIN_DEPOSIT_AMOUNT
;     assert len(pubkey) == PUBKEY_LENGTH
;     assert len(withdrawal_credentials) == WITHDRAWAL_CREDENTIALS_LENGTH
;     assert len(signature) == SIGNATURE_LENGTH

[deposit-init]
pc: 0 => 1798
word_stack: .WordStack
local_mem: .Map => {LOCAL_MEM_INIT}
gas:         #symGas(0 => 154)
memory_used: #symMem(0 => 154)
; gas: #gas(INIT_GAS, 0, 0) => _ /* #gas(INIT_GAS, 765, 82) */
; memory_used: 0 => _ /* 27 */

;    # Emit `DepositEvent` log
;    amount: bytes[8] = self.to_little_endian_64(deposit_amount)
;    log.DepositEvent(pubkey, withdrawal_credentials, amount, signature, self.to_little_endian_64(self.deposit_count))

[deposit-subcall_1]
pc: 1798 => 2073
word_stack: .WordStack
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_SUBCALL_1}
gas:         #symGas(N => N +Int 1298)
memory_used: #symMem(N => N +Int 1298)

[deposit-subcall_2]
pc: 2073 => 2373
word_stack: .WordStack
local_mem: {LOCAL_MEM_SUBCALL_1} => {LOCAL_MEM_SUBCALL_2}
gas:         #symGas(N => N +Int 1307)
memory_used: #symMem(N => N +Int 1307)

[deposit-log]
pc: 2373 => 3347
word_stack: .WordStack
local_mem: {LOCAL_MEM_SUBCALL_2} => {LOCAL_MEM_LOG}
gas:         #symGas(N => N +Int 2494)
memory_used: #symMem(N => N +Int 2494)
log: _ => _
; TODO: fix log
; log: _:List ( .List => ListItem(#abiEventLog(THIS, "DepositEvent",
;             #bytes(#buf({PUBKEY_LENGTH}, PUBKEY)),
;             #bytes(#buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)),
;             #bytes(#bufSeg(#buf(32, YY8), 24, 8)),
;             #bytes(#buf({SIGNATURE_LENGTH}, SIGNATURE)),
;             #bytes(#bufSeg(#buf(32, Y8), 24, 8)) )))

;    # Compute `DepositData` hash tree root
;    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000
;    pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH)))
;    signature_root: bytes32 = sha256(concat(
;        sha256(slice(signature, start=0, len=64)),                                                             <-- tmp1
;        sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)),                   <-- tmp2
;    ))
;    node: bytes32 = sha256(concat(
;        sha256(concat(pubkey_root, withdrawal_credentials)),                                                   <-- tmp3
;        sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)),          <-- tmp4
;    ))

; #### `DepositData`
;
; ```python
; class DepositData(Container):
;     pubkey: BLSPubkey
;     withdrawal_credentials: Hash
;     amount: Gwei
;     signature: BLSSignature
; ```

;                                    ___________________________ node _________________________
;                                   /                                                          \
;                    __________ tmp3 ___________________                        ______________ tmp4 _______________
;                   /                                   \                      /                                   \
;           pubkey_root                       withdrawal_credentials       amount                        _____ signature_root __________
;           /       \                                                                                   /                               \
;   pubkey[0:32]  pubkey[32:48]++zero[0:16]                                                           tmp1                             tmp2
;                                                                                                  /       \                        /        \
;                                                                                       signature[0:32]  signature[32:64]  signature[64:96]  zero[0:32]

[deposit-data]
pc: 3347 => 4217
word_stack: .WordStack
local_mem: {LOCAL_MEM_LOG} => {LOCAL_MEM_DATA}
gas:         #symGas(N => N +Int 573)
memory_used: #symMem(N => N +Int 573)

;    # Add `DepositData` hash tree root to Merkle tree (update a single `branch` node)
;    self.deposit_count += 1
;    size: uint256 = self.deposit_count
;    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):
;        if bitwise_and(size, 1) == 1:  # More gas efficient than `size % 2 == 1`
;            self.branch[height] = node
;            break
;        node = sha256(concat(self.branch[height], node))
;        size /= 2

[deposit-add]
WORD_STACK_INIT: 32 : 3392 : .WordStack
PC_BEGIN:    4217
PC_LOOPHEAD: 4457
PC_END:      4467

[deposit-add-init]
;

[deposit-add-init-then]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_BEGIN} => {PC_END}
word_stack: .WordStack
local_mem: {LOCAL_MEM_DATA} => {LOCAL_MEM_DATA}
    [ 3360 := #buf(32, DEPOSIT_COUNT +Int 1) ]          /* size: uint256 = self.deposit_count */
    [ 3392 := #buf(32, 0) ]                             /* height */
    [  192 := #buf(32, 0) ]
storage: M => M
    [ #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList) <- DEPOSIT_COUNT +Int 1 ]
    [ #hashedLocation({COMPILER}, {BRANCH}, 0)               <- {NODE} ]
refund: _ => _
+requires:
    // conditions
    andBool (DEPOSIT_COUNT +Int 1) &Int 1 ==Int 1
gas:         #symGas(N => N +Int 64)
memory_used: #symMem(N => N +Int 64)

[deposit-add-init-else]
pc: {PC_BEGIN} => {PC_LOOPHEAD}
word_stack: .WordStack => 1 : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_DATA} => {LOCAL_MEM_DATA}
    [ 3360 := #buf(32, DEPOSIT_COUNT +Int 1) ]          /* size: uint256 = self.deposit_count */
    [ 3392 := #buf(32, 0) ]                             /* height */
    [  192 := #buf(32, 0) ]
    [ 3456 := #buf(32, {BRANCH_0}) ]
    [ 3488 := #buf(32, {NODE}) ]
    [ 3424 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE_1}) ]                      /* sha256(3456, 64) */
    [ 2816 := #buf(32, {NODE_1}) ]                      /* node = sha256(concat(self.branch[height], node)) */
    [ 3360 := #buf(32, (DEPOSIT_COUNT +Int 1) /Int 2) ] /* update size */
    [ 3392 := #buf(32, 1) ]                             /* update height */
BRANCH_0: select(M, #hashedLocation({COMPILER}, {BRANCH}, 0))
NODE_1: #sha256(#buf(32, {BRANCH_0}) ++ #buf(32, {NODE}))
storage: M => M
    [ #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList) <- DEPOSIT_COUNT +Int 1 ]
refund: _ => _
+requires:
    // conditions
    andBool (DEPOSIT_COUNT +Int 1) &Int 1 =/=Int 1
gas:         #symGas(N => N +Int 128)
memory_used: #symMem(N => N +Int 128)

[deposit-add-loop]
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_DATA}
    [ 3360 := #buf(32, SIZE) ]                      /* size */
    [ 3392 := #buf(32, HEIGHT) ]                    /* height */
    [  192 := #buf(32, 0) ]
    [ 3456 := #buf(32, ANON_1) ]
    [ 3488 := #buf(32, ANON_2) ]
    [ 3424 := #buf(32, 64) ]
    [  192 := #buf(32, NODE) ]                      /* sha256(3456, 64) */
    [ 2816 := #buf(32, NODE) ]                      /* node = sha256(concat(self.branch[height], node)) */
+requires:
    // conditions
    andBool #range(0 <= HEIGHT <= 32)
    // types
    andBool #rangeUInt(256, NODE)
    andBool #rangeUInt(256, SIZE)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)

[deposit-add-loop-enter]
+requires:
    // conditions
    andBool HEIGHT <Int 32

[deposit-add-loop-enter-then]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_LOOPHEAD} => {PC_END}
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [  192 := #buf(32, 0) ]
storage: M => M
    [ #hashedLocation({COMPILER}, {BRANCH}, HEIGHT) <- NODE ]
refund: _ => _
+requires:
    // conditions
    andBool SIZE &Int 1 ==Int 1
gas:         #symGas(N => N +Int 39)
memory_used: #symMem(N => N +Int 39)

[deposit-add-loop-enter-else]
pc: {PC_LOOPHEAD}
word_stack: (HEIGHT => HEIGHT +Int 1) : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [  192 := #buf(32, 0) ]
    [ 3456 := #buf(32, {BRANCH_HEIGHT}) ]
    [ 3488 := #buf(32, NODE) ]
    [ 3424 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE_NEW}) ]                    /* sha256(3456, 64) */
    [ 2816 := #buf(32, {NODE_NEW}) ]                    /* node = sha256(concat(self.branch[height], node)) */
    [ 3360 := #buf(32, SIZE /Int 2) ]                   /* update size */
    [ 3392 := #buf(32, HEIGHT +Int 1) ]                 /* update height */
BRANCH_HEIGHT: select(M, #hashedLocation({COMPILER}, {BRANCH}, HEIGHT))
NODE_NEW: #sha256(#buf(32, {BRANCH_HEIGHT}) ++ #buf(32, NODE))
+requires:
    // conditions
    andBool SIZE &Int 1 =/=Int 1
gas:         #symGas(N => N +Int 103)
memory_used: #symMem(N => N +Int 103)

[deposit-add-loop-exit]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_LOOPHEAD} => {PC_END}
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD}
+requires:
    // conditions
    andBool HEIGHT ==Int 32
gas:         #symGas(N => N +Int 9)
memory_used: #symMem(N => N +Int 9)

;
; globals
;

[pgm]
COMPILER: "Vyper"
; Storage variables:
; branch: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]
; deposit_count: uint256
; zero_hashes: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]
BRANCH: 0
DEPOSIT_COUNT: 1
ZERO_HASHES: 2
; Constants:
; MIN_DEPOSIT_AMOUNT: constant(uint256) = 1000000000  # Gwei
; DEPOSIT_CONTRACT_TREE_DEPTH: constant(uint256) = 32
; MAX_DEPOSIT_COUNT: constant(uint256) = 4294967295 # 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1
; PUBKEY_LENGTH: constant(uint256) = 48  # bytes
; WITHDRAWAL_CREDENTIALS_LENGTH: constant(uint256) = 32  # bytes
; AMOUNT_LENGTH: constant(uint256) = 8  # bytes
; SIGNATURE_LENGTH: constant(uint256) = 96  # bytes
DEPOSIT_CONTRACT_TREE_DEPTH: 32
CODE: "0x600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052600015610277575b6101605261014052600061018052610140516101a0526101c060006008818352015b61018051600860008112156100da578060000360020a82046100e1565b8060020a82025b905090506101805260ff6101a051166101e052610180516101e0516101805101101561010c57600080fd5b6101e0516101805101610180526101a0517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86000811215610155578060000360020a820461015c565b8060020a82025b905090506101a0525b81516001018083528114156100bd575b50506018600860208206610200016020828401111561019357600080fd5b60208061022082610180600060046015f15050818152809050905090508051602001806102c0828460006004600a8704601201f16101d057600080fd5b50506102c05160206001820306601f82010390506103206102c0516008818352015b826103205111156102025761021e565b6000610320516102e001535b81516001018083528114156101f2575b50505060206102a05260406102c0510160206001820306601f8201039050610280525b6000610280511115156102535761026f565b602061028051036102a001516020610280510361028052610241565b610160515650005b63863a311b600051141561050857341561029057600080fd5b6000610140526101405161016052600154610180526101a060006020818352015b60016001610180511614156103325760006101a051602081106102d357600080fd5b600060c052602060c02001546020826102400101526020810190506101605160208261024001015260208101905080610240526102409050602060c0825160208401600060025af161032457600080fd5b60c0519050610160526103a0565b6000610160516020826101c00101526020810190506101a0516020811061035857600080fd5b600260c052602060c02001546020826101c0010152602081019050806101c0526101c09050602060c0825160208401600060025af161039657600080fd5b60c0519050610160525b61018060026103ae57600080fd5b60028151048152505b81516001018083528114156102b1575b505060006101605160208261044001015260208101905061014051610160516101805163806732896102c0526001546102e0526102e0516006580161009b565b506103405260006103a0525b6103405160206001820306601f82010390506103a0511015156104355761044e565b6103a05161036001526103a0516020016103a052610413565b61018052610160526101405261034060088060208461044001018260208501600060046012f150508051820191505060006018602082066103c0016020828401111561049957600080fd5b6020806103e082610140600060046015f150508181528090509050905060188060208461044001018260208501600060046014f150508051820191505080610440526104409050602060c0825160208401600060025af16104f957600080fd5b60c051905060005260206000f3005b63621fd130600051141561061a57341561052157600080fd5b63806732896101405260015461016052610160516006580161009b565b506101c0526000610220525b6101c05160206001820306601f82010390506102205110151561056c57610585565b610220516101e00152610220516020016102205261054a565b6101c0805160200180610280828460006004600a8704601201f16105a857600080fd5b50506102805160206001820306601f82010390506102e0610280516008818352015b826102e05111156105da576105f6565b60006102e0516102a001535b81516001018083528114156105ca575b5050506020610260526040610280510160206001820306601f8201039050610260f3005b63c47e300d600051141561117457606060046101403760506004356004016101a037603060043560040135111561065057600080fd5b604060243560040161022037602060243560040135111561067057600080fd5b608060443560040161028037606060443560040135111561069057600080fd5b63ffffffff600154106106a257600080fd5b633b9aca0061034052610340516106b857600080fd5b61034051340461032052633b9aca006103205110156106d657600080fd5b60306101a051146106e657600080fd5b602061022051146106f657600080fd5b6060610280511461070657600080fd5b6101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a05163806732896103c052610320516103e0526103e0516006580161009b565b506104405260006104a0525b6104405160206001820306601f82010390506104a051101515610796576107af565b6104a05161046001526104a0516020016104a052610774565b6103a05261038052610360526103405261032052610300526102e0526102c0526102a05261028052610260526102405261022052610200526101e0526101c0526101a052610440805160200180610360828460006004600a8704601201f161081657600080fd5b50506101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e05161040051610420516104405161046051610480516104a05163806732896104c0526001546104e0526104e0516006580161009b565b506105405260006105a0525b6105405160206001820306601f82010390506105a0511015156108c7576108e0565b6105a05161056001526105a0516020016105a0526108a5565b6104a05261048052610460526104405261042052610400526103e0526103c0526103a05261038052610360526103405261032052610300526102e0526102c0526102a05261028052610260526102405261022052610200526101e0526101c0526101a0526105408051602001806105c0828460006004600a8704601201f161096757600080fd5b505060a06106405261064051610680526101a08051602001806106405161068001828460006004600a8704601201f161099f57600080fd5b505061064051610680015160206001820306601f8201039050610640516106800161062081516040818352015b83610620511015156109dd576109fa565b6000610620516020850101535b81516001018083528114156109cc575b50505050602061064051610680015160206001820306601f820103905061064051010161064052610640516106a0526102208051602001806106405161068001828460006004600a8704601201f1610a5157600080fd5b505061064051610680015160206001820306601f8201039050610640516106800161062081516020818352015b8361062051101515610a8f57610aac565b6000610620516020850101535b8151600101808352811415610a7e575b50505050602061064051610680015160206001820306601f820103905061064051010161064052610640516106c0526103608051602001806106405161068001828460006004600a8704601201f1610b0357600080fd5b505061064051610680015160206001820306601f8201039050610640516106800161062081516020818352015b8361062051101515610b4157610b5e565b6000610620516020850101535b8151600101808352811415610b30575b50505050602061064051610680015160206001820306601f820103905061064051010161064052610640516106e0526102808051602001806106405161068001828460006004600a8704601201f1610bb557600080fd5b505061064051610680015160206001820306601f8201039050610640516106800161062081516060818352015b8361062051101515610bf357610c10565b6000610620516020850101535b8151600101808352811415610be2575b50505050602061064051610680015160206001820306601f82010390506106405101016106405261064051610700526105c08051602001806106405161068001828460006004600a8704601201f1610c6757600080fd5b505061064051610680015160206001820306601f8201039050610640516106800161062081516020818352015b8361062051101515610ca557610cc2565b6000610620516020850101535b8151600101808352811415610c94575b50505050602061064051610680015160206001820306601f8201039050610640510101610640527f649bbc62d0e31342afea4e5cd82d4049e7e1ee912fc0889aa790803be39038c561064051610680a160006107205260006101a06030806020846107e001018260208501600060046016f150508051820191505060006010602082066107600160208284011115610d5957600080fd5b60208061078082610720600060046015f15050818152809050905090506010806020846107e001018260208501600060046013f1505080518201915050806107e0526107e09050602060c0825160208401600060025af1610db957600080fd5b60c0519050610740526000600060406020820661088001610280518284011115610de257600080fd5b6060806108a0826020602088068803016102800160006004601bf1505081815280905090509050602060c0825160208401600060025af1610e2257600080fd5b60c0519050602082610a800101526020810190506000604060206020820661094001610280518284011115610e5657600080fd5b606080610960826020602088068803016102800160006004601bf1505081815280905090509050602080602084610a0001018260208501600060046015f150508051820191505061072051602082610a0001015260208101905080610a0052610a009050602060c0825160208401600060025af1610ed357600080fd5b60c0519050602082610a8001015260208101905080610a8052610a809050602060c0825160208401600060025af1610f0a57600080fd5b60c0519050610860526000600061074051602082610b20010152602081019050610220602080602084610b2001018260208501600060046015f150508051820191505080610b2052610b209050602060c0825160208401600060025af1610f7057600080fd5b60c0519050602082610ca00101526020810190506000610360600880602084610c2001018260208501600060046012f15050805182019150506000601860208206610ba00160208284011115610fc557600080fd5b602080610bc082610720600060046015f1505081815280905090509050601880602084610c2001018260208501600060046014f150508051820191505061086051602082610c2001015260208101905080610c2052610c209050602060c0825160208401600060025af161103857600080fd5b60c0519050602082610ca001015260208101905080610ca052610ca09050602060c0825160208401600060025af161106f57600080fd5b60c0519050610b0052600180546001825401101561108c57600080fd5b6001815401815550600154610d2052610d4060006020818352015b60016001610d20511614156110dc57610b0051610d4051602081106110cb57600080fd5b600060c052602060c0200155611170565b6000610d4051602081106110ef57600080fd5b600060c052602060c0200154602082610d60010152602081019050610b0051602082610d6001015260208101905080610d6052610d609050602060c0825160208401600060025af161114057600080fd5b60c0519050610b0052610d20600261115757600080fd5b60028151048152505b81516001018083528114156110a7575b5050005b60006000fd"
